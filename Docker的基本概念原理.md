@[TOC](目录)

## 前言
本文没有docker的具体操作指令，都是一些基本概念和一些原理。具体的操作请参考
[Docker手册](https://yeasy.gitbooks.io/docker_practice/content/)

## 1.Docker是什么
**Docker是一种容器。本质还是运行在操作系统上的一种应用程序。**
Docker 使用 Google 公司推出的 **Go 语言** 进行开发实现，基于 Linux 内核的cgroup，namespace，以及 AUFS 类的 Union FS 等技术，**对进程进行封装隔离**，属于操作系统层面的**虚拟化技术**。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为**容器**。


## 2.Docker 和虚拟机的区别
**虚拟机和Docker都是运行于操作系统上的进程**。区别：
|传统虚拟机|  Docker|
|--|--|
|  虚拟一套硬件|/  |
|  虚拟完整的操作系统|直接运行与宿主的内核。没有自己的内核 |
|一般体积大，占用资源|体积小，轻便|

##  3.Docker 的三大基本概念
### 3.1镜像
**Docker 镜像是一个特殊的文件系统。**
对于 Linux 而言，内核启动后，会挂载  root文件系统为其提供用户空间持。而 Docker 镜像（Image），就相当于是一个  root  文件系统。比如官方镜像  ubuntu:16.04  就包含了完整的一套 Ubuntu 16.04 最小系统的  root  文件系统。
**利用 **Union FS** 的技术，将其设计为分层存储的架构**。镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。
镜像构建时，会一层层构建，前一层是后一层的基础。
### 3.2容器
**Docker容器是镜像运行的实体。就像是面向对象程序设计中的  “类”  和  “实例”。镜像使用的是分层存储，容器也是如此。**
每一个容器运行时，是**以镜像为基础层，在其上创建一个当前容器的存储层**，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。
**它有生命周期**。所以容器可以被创建、启动、停止、删除。

### 3.3仓库
**存放Docker镜像的地方，类似于git仓库。有公有仓库，也有私有仓库。可以通过Docker指令pull，push镜像**。
### 3.4 三者关系
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190223170412951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xzd19kYWJhb2ppYW4=,size_16,color_FFFFFF,t_70)
## 4.数据卷
**数据卷是一个可供一个或多个容器使用的特殊目录，用来持久化数据。**
类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。
**具有如下特点：**
 - 数据卷可以在容器之间共享和重用
 -  对数据卷的修改会立马生效 
 - 对数据卷的更新，不会影响镜像数据卷 
 - 默认会一直存在，即使容器被删除，需要特殊指令删除

## 5.底层实现
### 5.1基本架构
Docker 采用了  C/S  架构，包括客户端和服务端。Docker 守护进程 （ Daemon  ）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。
客户端和服务端既可以运行在一个机器上，也可通过  socket  或者  RESTful API  来进行通信。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190223171726417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xzd19kYWJhb2ppYW4=,size_16,color_FFFFFF,t_70)
### 5.2命名空间
**命名空间保证了容器之间彼此互不影响**。命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。
这其中包括了PID（进程）、NET（网络）、IPC（进程通信）、mnt（挂载的目录）、UTS("UNIX Time-sharing System") 、user 命名空间。
### 5.3控制组
**控制组主要用来对共享资源进行隔离、限制、审计等。**
控制组（cgroups）是 Linux 内核的一个特性。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。
控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。
###  5.4联合文件系统（敲黑板！！！）
**联合文件系统**（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。
**联合文件系统是 Docker 镜像的基础**。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。
另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。
Docker 中使用的 **AUFS**（AnotherUnionFS）就是一种联合文件系统。

###  5.5容器格式
最初，Docker 采用了  LXC  中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。
对更多容器格式的支持，还在进一步的发展中。
**containerd**主要职责是镜像管理（镜像、元信息等）、容器执行（调用最终运行时组件执行）。
**runC**是从Docker的libcontainer中迁移而来的，实现了容器启停、资源隔离等功能。OCI定义了容器运行时标准，runC是Docker按照开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。

###  5.6网络
Docker 的网络实现其实就是利用了 Linux 上的网络命名空间和虚拟网络设备（特别是 vethpair）。
首先，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包；此外，如果不同子网之间要进行通信，需要路由机制。
**Docker 中的网络接口默认都是虚拟的接口**。Docker 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做  veth pair  ）。
## 其他链接

[containerd，runc，docker-shim](https://www.jianshu.com/p/52c0f12b0294)
[docker入门与实战](https://yeasy.gitbooks.io/docker_practice/content/)