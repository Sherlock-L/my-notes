@[TOC](目录)
# 前言
从大学到现在工作的日子里，有些名词概念总是不经意间出现在某些场合，来也匆匆，去也匆匆。可能由于偏底层，虽然它们经常被提起，却又容易被遗忘。这里我把其中一的部分给拎出来，旨在简单记住其形态和关系。具体深度解读自行查阅书籍。其中包括：
 - 进程、线程、协程
 - 同步、异步
 - IO、IO阻塞、IO非阻塞、同步IO阻塞、同步IO非阻塞、异步IO非阻塞、~~异步IO阻塞（有意义吗？）~~ 
 - 多核CPU、单核CPU
 - 时间片、上下文
 - CPU密集型、IO密集型
 
# 1.进程、线程、协程、
|  名称|简单来说| 特点 |官方点说|
|:--|:--|:--|:--|
| 进程 | **操作系统**中运行程序的基本实体。|1.进程之间的资源是相互隔离的，安全的。<br>2.进程有专门的方式互相通信|系统进行资源分配和调度的基本单位。每一个进程都有它自己的地址空间。一般情况下，包括文本区域、数据区域和堆栈。 
| 线程|**cpu调用**的基本单位。如果进程是任务， 线程就是它的子任务|1.一个进程里有多个线程，就叫多线程。它们共享当前所属进程所拥有的资源 。<br>**2.线程调用受cpu规则控制**。如cpu利用时间片，每个线程执行10ms，然后轮到下一个线程执行|线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
| 协程|**协程是一种用户态的轻量级线程**。|1.一个进程里有多个协程，它互相配合。<br>**2.协称调用受用户程序控制**。如先做饭还是先烧菜，由程序控制|协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快


# 2.同步、异步
|  名称|简单来说| 特点 |
|:--|:--|:--|:--|
| 同步 |后一个任务要等前一个执行完才开始.|很多场景资源利用率低 |
| 异步|一个任务执行后，不用等待返回执行结果，直接进行下一步任务|任务等待时间少。|


# 3. IO操作、IO阻塞、IO非阻塞、同步IO阻塞、同步IO非阻塞、异步IO非阻塞、
**首先IO过程主要分两个阶段：
1.数据准备阶段
2.内核空间复制回用户进程缓冲区空间**

> 引用自  https://blog.csdn.net/evanxuhe/article/details/79627709 
> 废话不说，老张爱喝茶，煮开水，有两个水壶，普通水壶，响水壶（水开会提示）
>- 同步就是普通水壶烧开水，要没事儿自己过来来看开没开； 
>- 异步就是响水壶烧开水，水开了水壶响了通知你。 
>- 阻塞是烧开水的过程中，你不能干其他事情（即你被阻塞住了），只能站那等水开； 
>- 非阻塞是烧开水的过程里可以干其他事情。比如去客厅看看电视；


|  名称|简单来说| 特点 |官方点说
|:--|:--|:--|:--|
| IO操作 |输入、输出流。如磁盘文件的读写、网络io通信等操作 |传输性能有瓶颈|例如Linux下系统IO主要就是通过以下几个函数open(),close(),read(),write(),send(),recv(),lseek()。<br>就是当你调用recv()函数时，整个进程或者线程就等待在这里了，直到你recv的fd的所有信息都被send过来，这么做好处就是保证所有信息都能够完整的读取了，但劣势也很明显，就是在recv()的过程中你的进程或线程做不了其它事情，由此，引入了非阻塞IO
| IO阻塞|从发起io请求，一直等待执行返回结果，途中不做别的|占用资源，很多时候都在等待结果，使得其他进程或者线程被迫等待|当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。
|IO非阻塞|发起io请求后，不等待结果，直接返回，可执行其他操作|避免等待时间浪费|  当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br> 所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。
| 同步IO阻塞|也就是上面说的IO阻塞
|同步IO非阻塞|发起IO请求后，无需等待数据到达。直接返回，做别的任务。但是有数据到达后，还是要花时间读取执行。
|异步IO非阻塞|发起IO请求后，无需等待数据到达。但是有数据到达后，由内核去完成后续的操作。可以继续做别的任务。||

# 4. 多核CPU、单核CPU、多CPU
|  名称|简单来说| 官方点说
|:--|:--|:--|:--|
| 多核CPU |多个CPU处理模块，可以同时执行多个线程|多核CPU即多个CPU组成，这些CPU集成在一个芯片里，可以通过内部总线来交互数据，共享数据，这些CPU中分配出一个独立的核执行操作系统，每个核都有自己的寄存器，alu运算单元等（这些都是封装在cpu内部的），但是一级二级缓存是共享的，这些CPU通过总线来交互数据，并且工作是并行的，资源分配是由操作系统来完成的，操作系统来决定程序cpu的控制权分配
| 单核CPU|一个CPU处理模块。同一时间只能执行单个线程|
| 多CPU|一台主机上拥有存在不同芯片上的cpu|每个cpu只能用来独立执行不同的程序，这些cpu都是单核的，因为单核cpu执行一个程序比来回跳转执行的速度要快很多，但是难以管理，因为每个CPU有自己的总线，一级二级缓存，那么这样需要更大的占用面积，更多的总线，因为这些CPU不是封装在一个芯片里。

# 5.时间片、上下文
|  名称|简单来说| 官方点说 |
|:--|:--|:--|:--|
| 时间片 |CPU分给线程执行的时间；片段分配，比如一个线程一片，一片10ms。用完再分|CPU分配给各个程序的时间,使各个程序从表面上看是同时进行的,而不会造成CPU资源浪费
| 上下文|简单来说就是所处环境的各方面信息|上下文是从英文context翻译过来，指的是一种环境。相对于进程而言，就是进程执行时的环境；具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。

# 6.CPU密集、IO密集
|  名称|简单来说| 官方点说 |
|:--|:--|:--|:--|
| CPU密集 |CPU使用比较高|CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。**CPU bound**的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间
| IO密集|硬盘读写或者网络IO运作比较密集|IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。

参考链接：
[深入了解几种IO模型（阻塞非阻塞，同步异步）](https://blog.csdn.net/zk3326312/article/details/79400805)
[同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别](https://www.cnblogs.com/euphie/p/6376508.html)
[网络编程中，阻塞、非阻塞、同步、异步总结](https://www.cnblogs.com/Anker/p/3254269.html)
                      